---
title: fullpage 기능 라이브러리 없이 구현하기
description: 사먹는 것보다 맛있습니다.
date: 2023-07-02
tags: react
---

# fullpage란?

blog의 메인화면을 fullpage로 만들고싶다는 생각이 들었습니다.

**그래서 본 포스트에서는 제가 fullpage를 구현하며 만난 문제들과 해결과정을 소개합니다.!**

[배달의 민족 홈페이지](https://www.baemin.com) 와 같이

한번 스크롤하면 전체페이지가 넘어가는 기능을 의미합니다.

![image](/2023/fullpage/1.PNG)

이런 형태의 사이트를 보신 경험이 있을 것입니다.

이러한 fullpage를 지원해주는 다양한 라이브러리들이 존재하는데 조금씩 아쉬운 부분들이 있습니다.

`@fullpage/react-fullpage` , `react-fullpage` 등등이 있지만

fullpage는 상업적 용도로 사용을 원할 경우 라이센스를 구매해야하는 문제가 있고

그 외 라이브러리들은 타입스크립트 지원이 미약한 경우가 많았습니다.

swiper 등 캐러셀을 지원해주는 라이브러리를 통해 fullpage를 구현하는 방법도 존재하지만

swiper 의 디자인을 커스텀하는 것이 조금 귀찮은 면이 있어

**저는 직접 구현하는 방식을 택했습니다.**

### 시도한 환경

`next.js` `typescript` 환경에서 코드를 작성했습니다.

next.js의 경우에는 app dir을 이용하여 작성했습니다.

## 기능 정의

1. 위에서 확인한 배달의 민족 페이지처럼 우측 중앙의 버튼을 클릭하면 해당 위치로 부드럽게 이동하면 좋겠습니다.

2. 스크롤을 내리고 있는 중간에는 스크롤을 제어할 수 없어야 합니다.

3. 맨처음 / 맨마지막 부분에 도달하면 스크롤을 올리거나 / 내려도 아무런 일이 일어나지 않아야합니다.

제법 까다로운 조건이네요 이러한 기능들을 구현하기 위해서는

이벤트와 css 전반에 대한 이해가 필요합니다.

## css 부터 준비하기

우선 fullpage를 위해 특정 요소가 페이지를 꽉 채우도록 할 필요가 있습니다.

이는 css 속성과 연관이 있는데 vh , vw 단위를 사용하면 손쉽게 해결할 수 있습니다.

```css
.item {
  height: 100vh;
  width: 100vw;
}
```

**혹은 % 단위를 이용해도 좋습니다.**

항상 뷰포트의 전체를 너비로 가지는 div 박스를 만들어주면 우리가 원하는대로 한페이지를 꽉 채우는 것이 가능해집니다.

이러한 아이템들을 여러개 나열시켜주면 우리가 원하는 페이지의 틀이 되는 것이지요

```jsx
return (
  <div className="flex flex-col">
    <div className=" h-screen w-screen">1번 페이지</div>
    <div className=" h-screen w-screen">2번 페이지</div>
    <div className=" h-screen w-screen">3번 페이지</div>
    <div className=" h-screen w-screen">4번 페이지</div>
  </div>
);
```

tailwind-css를 사용하고 있다면 이런식으로 작성할 수도 있습니다.

이제 이렇게 만들어진 div 박스들을 한번 스크롤했을때 아래나 위로 전체가 이동하게 해주면 되는것입니다.

하지만 그 이전에 해야할 작업들이 몇가지 더 있습니다.

바로 header와 / 우측중앙의 이동버튼들은 항상 화면에 표시되어야 한다는 것입니다.

항상 같은 곳에 표시되게 하는 대표적인 방법은 position 속성과 연관이 있습니다.

```css
position : sticky
position : fixed
```

등이 대표적이지요

css의 position 속성은 html 요소가 어떻게 배치되어질지를 결정하는 속성입니다.

다양한 방법이 존재하지만 본 포스트에서는 fixed를 활용하여 배치를 하겠습니다.

position 값을 fixed로 지정해주면 부모 요소로부터 완전히 독립되어 원하는 위치에 배치할 수 있게 됩니다.

**또한 스크롤링이 되는 동안에도 지정된 자리에 고정되어 있다는 특징이 있습니다.**

바로 이 부분이 position:absolute 와의 큰 차이점입니다.

absolute는 스크롤링이 되면 같이 화면에서 사라지게 되거든요!

[MDN의 position 속성 소개](https://developer.mozilla.org/ko/docs/Web/CSS/position) 를 참고해보세요

다시 본론으로 돌아와서 fixed 속성은 원하는 위치에 배치할 수 있다는 특징이 있다고 했죠?

그래서 top , left, right, bottom 속성을 함께 지정해주어야 원하는 위치에 잘 배치할 수 있습니다.

반드시 저 네가지 속성을 다 지정해줄 필요는 없지만 필요하다면 지정을 해야겠죠?

```jsx
  <div className=" fixed top-1/2 right-10">
```

tailwind-css에서는 top-1/2로 간편하게 지정해줄 수 있고

바닐라 css에서는

```css
top: 50%;
```

와 같이 퍼센트로 지정해주면 중앙에 위치시킬 수 있습니다.

헤더도 마찬가지의 논리로 속성들의 값을 줘보면서 지정해보세요

그러면 이제 css는 마무리하도록 하겠습니다.

## Wheel 이벤트 이해하기

마우스 휠이나 유사한 입력 장치를 움직일 때 WheelEvent가 발생합니다.

WheelEvent는

```
Event <- UIEvent <- MouseEvent <- WheelEvent
```

이러한 구조로 상속관계가 이루어집니다.

WheelEvent만 독자적으로 가지고 있는 속성들이 있다는 의미이지요

```js
WheelEvent.deltaX;
WheelEvent.deltaY;
WheelEvent.deltaZ;
WheelEvent.deltaMode;
```

WheelEvent는 이러한 읽기전용 속성을 가집니다.

여기에서 지금 구현에 필요한 것은 `deltaY` 속성입니다.

**deltaY 속성은 세로 스크롤의 양을 나타내는 `number` 값을 반환합니다.**

그외에도 휠이벤트 객체에는 상속받은 다양한 프로퍼티들이 존재하니 이것들은 직접 실습을 해보시길 권합니다.

```js
window.addEventListener('wheel', (event) => console.log(event));
window.addEventListener('scroll', (event) => console.log(event));
```

와 같은 형태로 실습할 수 있습니다.

### Wheel Event ? Scroll Event?

휠 이벤트와 유사한 형태로 동작하는 scroll event도 존재합니다.

이 둘은

scroll : 문서가 스크롤이 될 때 실행

wheel : 마우스 휠을 조작할 때 실행

된다는 차이점이 있으며

scroll 객체에는 deltaY 등 Wheel 이벤트가 가지고 있는 속성이 존재하지 않는다는 차이점도 존재합니다.

본론으로 돌아와 wheel 이벤트의 `deltaY`의 값은 실제로 실행해보면

![wheel event](/2023/fullpage/2.PNG)

스크롤을 내릴때에는 200과 같은 양수가 반환되고

스크롤을 올릴때에는 -200과 같이 음수가 반환되는 것을 알 수 있습니다.

**즉 deltaY의 값이 0보다 큰가 작은가를 통해 스크롤이 위로 올라갔는지 아래로 올라갔는지 판별 할 수 있습니다.**

## 실제 코드로 옮겨보기

```jsx
hooks/useFullPage.tsx

const useFullPage = (pageList: PageList[]) => {
  const [windowObj, setWindowObj] = React.useState<Window>();
  const [currentPageNum, setCurrentPageNum] = React.useState(1);
  const totalPageLen = pageList.length;
  const pageRefList = React.useRef<HTMLDivElement[]>([]);
  const [timestamp, setTimestamp] = React.useState(0);

  return <div></div>
}
```

로직이 굉장히 비대해질테니 커스텀훅의 형태로 작성해주도록 하겠습니다.

**windowObj** 는 window 객체를 담아둘 state입니다.

next.js 에서 하이드레이션 에러를 방지하기 위해 window 객체가 undefined인지 아닌지에 따라

분기처리가 필요하기에 생성해주었습니다.

**currentPageNum** 은 현재 페이지를 나타내는 useState입니다.

현재 페이지가 어디인지 알 수 있어야 현재 페이지를 표시해줄 수 있을 것입니다.

**totalPageLen** 은 내 fullpage의 총 갯수를 나타냅니다.

**pageRefList** 는 각각의 fullpage를 인식하고 관리할 수 있도록 하기 위한 장치입니다.

**timestamp** 는 이후 성능 최적화에서 사용할 state입니다.

**pageList** 는 커스텀훅이 인자로 받을 값입니다. pageList에 대한 타입을 정의해줘야겠네요

```jsx
export interface PageList<T = any> {
  pageNum: number;
  background: string;
  component: (arg: T) => React.JSX.Element;
}
```

페이지 넘버와 배경색 그리고 내부에서 렌더링 될 콘텐츠들을 갖고있는 component를 갖고있는 객체로 지정해줬습니다.

```jsx
React.useEffect(() => {
  if (window !== undefined) setWindowObj(window);
}, []);
```

우선 첫 마운트 시점에 window 객체가 존재하면 window객체를 기억하도록 코드를 작성합니다.

```jsx
const currentPageChange = React.useCallback(
      (event: Event) => {
        let scroll = windowObj?.scrollY!;
        for (let i = 1; i <= totalPageLen; i++) {
          if (
            scroll >
              pageRefList.current[i].offsetTop - windowObj!.outerHeight / 3 &&
            scroll <
              pageRefList.current[i].offsetTop -
                windowObj!.outerHeight / 3 +
                pageRefList.current[i].offsetHeight
          ) {
            setCurrentPageNum(i);
            break;
          }
        }
      },
      [totalPageLen, windowObj],
    )
```

이제 페이지가 바뀌면 바뀐 페이지를 인식할 수 있도록 코드를 작성해봅시다.

옵셔널체이닝연산자와 타입스크립트의 `assertion operator` '!' 를 이용하여

타입스크립트가 에러를 발생시키지 않도록 합니다.

**offsetTop** 속성은 요소의 y축 위치 값을 가져오는 속성입니다.

**outerHeight** 속성은 사이드바, 창 크기 조정 테두리/핸들을 포함하여 전체 브라우저 창의 높이를 픽셀 단위로 반환하는 속성입니다.
